<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Springboot 启动相关">
<meta property="og:type" content="article">
<meta property="og:title" content="Springboot 启动相关">
<meta property="og:url" content="http://yoursite.com/2019/04/01/Springboot 启动相关/index.html">
<meta property="og:site_name" content="Never的博客">
<meta property="og:description" content="Springboot 启动相关">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-31T11:28:44.642Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Springboot 启动相关">
<meta name="twitter:description" content="Springboot 启动相关">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/01/Springboot 启动相关/"/>





  <title>Springboot 启动相关 | Never的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Never的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/Springboot 启动相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Never">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Never.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Never的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Springboot 启动相关</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T09:19:58+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2019/04/01/Springboot 启动相关/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2019/04/01/Springboot 启动相关/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Springboot-启动相关"><a href="#Springboot-启动相关" class="headerlink" title="Springboot 启动相关"></a>Springboot 启动相关</h3><a id="more"></a>
<p><a href="https://www.cnblogs.com/xinzhao/p/5551828.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinzhao/p/5551828.html</a></p>
<p>入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进入run方法</strong>，首先创建了SpringApplication对象，并调用该对象的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object source, String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> run(<span class="keyword">new</span> Object[]&#123;source&#125;, args);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(sources)).run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建完<strong>SpringApplication</strong>后，构造函数中调用了<strong>initialize</strong>方法，初始化每一个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Object... sources)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">      <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.headless = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.additionalProfiles = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="comment">//我们传进来的参数</span></span><br><span class="line">      <span class="keyword">this</span>.initialize(sources);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为成员变量sources赋值 </span></span><br><span class="line">     <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//为接下来每一个变量赋值</span></span><br><span class="line">     <span class="keyword">this</span>.webEnvironment = <span class="keyword">this</span>.deduceWebEnvironment();                              <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">     <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">     <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>webEnvironment是一个boolean 类型的值，用来表示当前的应用程序是不是一个web应用程序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过在classpath 中查找是否存在 WEB_ENVIRONMENT_CLASSES这个数组所包含的类，如果存在那么当前程序是一个web 程序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">deduceWebEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] var1 = WEB_ENVIRONMENT_CLASSES;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            String className = var1[var3];</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>initializers成员变量，是一个ApplicationContextInitializer类型对象的集合。 顾名思义，ApplicationContextInitializer是一个可以用来初始化ApplicationContext的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用getSpringFactoriesInstances(ApplicationContextInitializer.class)，来获取ApplicationContextInitializer类型对象的列表。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitializers</span><span class="params">(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initializers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">this</span>.initializers.addAll(initializers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSpringFactoriesInstances(type, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">        List&lt;T&gt; instances = <span class="keyword">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">        AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">        <span class="keyword">return</span> instances;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过SpringFactoriesLoader.loadFactoryNames(type, classLoader)来获取所有Spring  Factories的名字，然后调用createSpringFactoriesInstances方法根据读取到的名字创建对象，最后将创建好的对象列表排序返回。在loadFactoryNames中主要为  classLoader.getResources(“META-INF/spring.factories”) ，则从中读取最近的ConfigurationWarningsApplicationContextInitializer，ContextIdApplicationContextInitializer，DelegatingApplicationContextInitializer，ServerPortInfoApplicationContextInitializer这四个类的名字</p>
<p>之后创建ApplicationContextInitializer实例，为4个组成的list</p>
<ol>
<li>listeners成员变量，是一个ApplicationListener&lt;?&gt;类型对象的集合。可以看到获取该成员变量内容使用的是跟成员变量initializers一样的方法，只不过传入的类型从ApplicationContextInitializer.class变成了ApplicationListener.class。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">this</span>.listeners.addAll(listeners);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在deduceMainApplicationClass方法中，通过获取当前调用栈，找到入口方法main所在的类，并将其复制给SpringApplication对象的成员变量mainApplicationClass</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">this</span>.listeners.addAll(listeners);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始化完毕后，将调用run 方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>设置系统属性java.awt.headless</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.configureHeadlessProperty();</span><br></pre></td></tr></table></figure>
<ol>
<li>在创建和更新ApplicationContext前后分别调用了started方法和finished方法, 并在创建和刷新ApplicationContext时，将listeners作为参数传递到了createAndRefreshContext方法中，以便在创建和刷新ApplicationContext的不同阶段，调用listeners的相应方法以执行操作。所以，所谓的SpringApplicationRunListeners实际上就是在SpringApplication对象的run方法执行的不同阶段，去执行一些操作，加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br></pre></td></tr></table></figure>
<p>另外EventPublishingRunListener在对象初始化时，将SpringApplication对象的成员变量listeners全都保存下来，然后在自己的public方法被调用时，发布相应的事件，或执行相应的操作。可以说这个RunListener是在SpringApplication对象的run方法执行到不同的阶段时，发布相应的event给SpringApplication对象的成员变量listeners中记录的事件监听器。</p>
<ol>
<li>接下来 创建并刷新ApplicationContext，并最后调用afterRefresh方法在刷新之后做一些操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">            <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">            <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">            <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            listeners.finished(context, (Throwable)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>然后ApplicationListener进行响应事件，其中 LoggingApplicationListener响应该事件，并对在ApplicationStarted时加载的LoggingSystem做一些初始化工作，之后会打印banner</p>
<p>创建ApplicationContext，当检测到本次程序是一个web应用程序（成员变量webEnvironment为true）的时候，就加载类DEFAULT_WEB_CONTEXT_CLASS，否则的话加载DEFAULT_CONTEXT_CLASS。</p>
<h5 id="Application-run关键："><a href="#Application-run关键：" class="headerlink" title="Application run关键："></a>Application run关键：</h5><ol>
<li><p>创建了应用的监听器，并开始监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载了SpringBoot配置环境（ConfigurableEnvironment），如果当前是通过web 容器发布（通过成员变量webEnvironment判断），会加载StandardEnvironment，最终也是继承了ConfigurableEnvironment。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br></pre></td></tr></table></figure>
<ol>
<li>配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</li>
<li>创建run方法的返回对象，ConfigurableApplicationContext(应用配置上下文)，该方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回，ConfigurableApplicationContex</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">        <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                contextClass = Class.forName(<span class="keyword">this</span>.webEnvironment ? <span class="string">"org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext"</span> : <span class="string">"org.springframework.context.annotation.AnnotationConfigApplicationContext"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ConfigurableApplicationContext)BeanUtils.instantiate(contextClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>回到run 中，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>
<ol>
<li>接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">      Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">      ((AbstractApplicationContext)applicationContext).refresh();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成。</p>
<p>Springboot 在启动时，加载了@SpringBootApplication注解主配置类，在注解主配置类里面的主要功能是为speingboot 开启了一个 @EnableAutoConfiguration 注解的自动配置功能，EnableAutoConfiguration 主要利用了<strong>AutoConfigurationImportSelector</strong>来导入一些组件，主要是 扫描 META-INF/spring.factories文件，从中获取要交给spring的所有组件</p>
<h4 id="Spring-IOC；"><a href="#Spring-IOC；" class="headerlink" title="Spring IOC；"></a>Spring IOC；</h4><p>ico的实现类，顶层为BeanFactory接口，有一个为ApplicationContext的子接口，其实现类都为IOC容器，因为 ApplicationContext功能强大，可以通过配置文件来实现功能，所以我们用这接口的实现类，比如（ApplicationContext ctx = new ClassPathXmlApplicationContext(“com/yf/context/beans.xml”)）</p>
<p>IOC的生命周期可以总结为：oc容器创建（其实就是类实例化，但是还没有属性赋值等操作）——–&gt;加载所有bean的定义信息——–&gt;创建bean的实例———&gt;属性赋值（调用bean的setxxx方法）———-&gt;假如bean实现了xxxAware接口，就执行setXXX方法———-&gt;执行初始化方法（相当于xml<bean init-method="初始化方法">）———–&gt;ioc容器创建完成，执行一些逻辑代码————-&gt;Web应用关闭，ioc容器销毁。</bean></p>
<p>Spring IOC ：</p>
<ol>
<li>Bean定义的定位,Bean 可能定义在XML中，或者一个注解，或者其他形式。这些都被用Resource来定位, 读取Resource获取BeanDefinition 注册到 Bean定义注册表中。</li>
<li>第一次向容器getBean操作会触发Bean的创建过程,实列化一个Bean时 ,根据BeanDefinition中类信息等实列化Bean.</li>
<li>将实列化的Bean放到单列Bean缓存内。</li>
<li>此后再次获取向容器getBean就会从缓存中获取。</li>
</ol>
<p>主要为refresh方法，在AbstractAplicationContext中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">          <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">          ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">          <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">              <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">              <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">              <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">              <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">              <span class="keyword">this</span>.onRefresh();</span><br><span class="line">              <span class="keyword">this</span>.registerListeners();</span><br><span class="line">              <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">              <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">              <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">              <span class="keyword">throw</span> var9;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); 中进入代码后，有一个refreshBeanFactory方法，该方法判断了是否存在基础的BeanFactory容器，有的话就销毁，接着用 createBeanFactory() 方法创建了一个 DefaultListableBeanFactory。ApplicationContext 是在基础 BeanFactory 上添加了高级容器特征的 IoC 容器，而且大多数情况下是使用 DefaultListableBeanFactory 这个具有基础容器功能的 BeanFactory。接着就是 loadBeanDefinitions 调用的地方，首先得到 BeanDefinition 的 Resource 定位。</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC容器的初始化过程可以分为三步：</p>
<ol>
<li>Resource定位（Bean的定义文件定位）</li>
<li>将Resource定位好的资源载入到BeanDefinition</li>
<li>将BeanDefiniton注册到容器中</li>
</ol>
<p>一、Resource定位：</p>
<p> Resource是Spring中用于封装I/O的接口，在创建spring容器时，通常要访问XML配置文件，除此之外还可以通过访问文件类型、二进制流等方式访问资源，还有当需要网络上的资源时可以通过访问URL，Spring把这些文件统称为Resource。 其次Spring 提供了ResourceLoader接口用于实现不同的Resource加载策略，该接口的实例对可以获取一个resource对象，ResourceLoader定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>; <span class="comment">//通过提供的资源location参数获取Resource实例</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>; <span class="comment">// 获取ClassLoader,通过ClassLoader可将资源载入JVM</span></span><br></pre></td></tr></table></figure>
<p>ApplicationContext的所有实现类都实现RecourceLoader接口，因此可以直接调用getResource（参数）获取Resoure对象<strong>。</strong>不同的ApplicatonContext实现类使用getResource方法取得的资源类型不同</p>
<p>二、通过返回的resource对象，进行BeanDefinition的载入</p>
<p>BeanDefinition相当于一个数据结构，这个数据结构的生成过程根据定位的resource资源对象中的bean而来，这些bean在springIoc容器内部成 了BeanDefinition这样的数据结构，IOC容器对bean的管理和依赖注入都是通过BeanDefinition来进行的。</p>
<p>在Spring中配置文件主要格式是XML，对于用来读取XML型资源文件来进行初始化的IoC 容器而言，该类容器会使用到AbstractXmlApplicationContext类，该类定义了一个名为loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 的方法用于获取BeanDefinition，该方法new一个与容器对应的BeanDefinitionReader型实例对象，然后将生成的BeanDefintionReader实例作为参数传入loadBeanDefintions(XmlBeanDefinitionReader)，继续往下执行载入BeanDefintion的过程。将所有定位的resource的资源位置（用户定义）以及本地所有配置文件的位置即容器本身资源全部加载到reader中，并调用reader.loadBeanDefinitions方法。  处理的过程主要可以为，先把resource包装为EncodeResource类型，之后读取resource对象得到XML的文件流，从资源中加载Docunment对象，最后将document文件的bean封装成BeanDefinition,并注册到容器。</p>
<p>三、将ReanDefinition注册到容器中</p>
<p>最终Bean配置会被解析成BeanDefinition并与beanName,Alias一同封装到<strong>BeanDefinitionHolder类</strong>中， 之后beanFactory.registerBeanDefinition(beanName, bdHolder.getBeanDefinition())，注册到<strong>DefaultListableBeanFactory</strong>.beanDefinitionMap中。之后客户端如果要获取Bean对象，Spring容器会根据注册的BeanDefinition信息进行实例化。（<strong>beanDefinitionMap是个ConcurrentHashMap类型数据，用于存放beanDefinition,它的key值是beanName</strong>）</p>
<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><p>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。</p>
<p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p>通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</p>
<p>切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
<p>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。</p>
<p>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p>aop可以分为静态代理和动态代理</p>
<p>静态代理是指使用aop框架提供的命令进行编译，从而在编译阶段就可以生成aop代理类，因此也称为编译时增强，动态代理则是在运行时借助JDK动态代理、CGLIB等在内存中‘’临时‘’生成aop动态代理类，因此也被称为运行时增强</p>
<p> JDK动态代理：默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现</p>
<ul>
<li>Spring 1.2 <strong>基于接口的配置</strong>：最早的 Spring AOP 是完全基于几个接口的</li>
<li>Spring 2.0 <strong>schema-based 配置</strong>：Spring 2.0 以后使用 XML 的方式来配置，使用 命名空间 <code>&lt;aop /&gt;</code></li>
<li>Spring 2.0 <strong>@AspectJ 配置</strong>：使用注解的方式来配置，这种方式感觉是最方便的，还有，这里虽然叫做 <code>@AspectJ</code>，但是这个和 AspectJ 其实没啥关系。</li>
</ul>
<p>用Advisor 表示 用于拦截的类，advice 是指用来切入的方法。最后需要定义需要代理的类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logArgsAspect"</span>&gt;</span>  //，一个bean 该bean中写处理代码</span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"internalPointcut"</span> //具体实现的方法织入到合适的<span class="attr">pointcut</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">"com.javadoop.SystemArchitecture.businessService()"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">// pointcut 就是配置我们需要拦截哪些方法，接下来，我们要配置需要对这些被拦截的方法做什么，也就是前面介绍的 Advice</span><br></pre></td></tr></table></figure>
<p>通过配置Spring的中&lt;<a href="aop:config" target="_blank" rel="noopener">aop:config</a>&gt;标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理</p>
<p><strong>JDK动态代理</strong></p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 </li>
</ol>
<p><strong>GCLIB代理</strong> </p>
<ol>
<li>cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。</li>
<li>cglib封装了asm，可以在运行期动态生成新的class。</li>
</ol>
<p>区别： </p>
<ol>
<li>JDK的动态代理必须基于接口，CGLIB没有这个要求，如果目标对象实现了接口，默认情况下采用JDK动态代理，可以强制使用CGLIB，如果没实现接口，必须采用CGLIB</li>
<li>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类 </li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final</li>
</ol>
<p>JDK：动态代理类JDKProxy，实现InvocationHandler接口，并且实现接口中的invoke方法。当客户端调用代理对象的业务方法时，代理对象执行invoke方法，invoke方法把调用委派给targetObject，相当于调用目标对象的方法，在invoke方法委派前判断权限，实现方法的拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxyInstance</span><span class="params">(Object targetObject)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.targetObject.getClass().getClassLoader(),</span><br><span class="line">               <span class="keyword">this</span>.targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB:实现了创建子类的方法与代理的方法。getProxy(SuperClass.class)方法通过入参即父类的字节码，扩展父类的class来创建代理对象。intercept()方法拦截所有目标类方法的调用，obj表示目标类的实例，method为目标类方法的反射对象，args为方法的动态入参，methodProxy为代理类实例。method.invoke(targetObject, args)通过代理类调用父类中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxyObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.targetObject = obj;</span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       enhancer.setSuperclass(obj.getClass());</span><br><span class="line">       <span class="comment">//回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法 </span></span><br><span class="line">       enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">//增强后的目标类</span></span><br><span class="line">       Object proxyObj = enhancer.create();</span><br><span class="line">       <span class="comment">// 返回代理对象</span></span><br><span class="line">       <span class="keyword">return</span> proxyObj;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>select的几大缺点：</strong></p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，默认是1024</strong></p>
<p>epoll的提升：</p>
<ol>
<li>本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；</li>
<li>效率提升：只有活跃的socket才会主动的去调用callback函数；</li>
<li>省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。</li>
<li>epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生， 每一次注册新的事件。都会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝，保证了每一个fd在整个过程只会拷贝一次。</li>
<li>epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）</li>
<li>epoll所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048</li>
</ol>
<p>总结：</p>
<p>1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/31/同源策略与跨域/" rel="next" title="同源策略与跨域">
                <i class="fa fa-chevron-left"></i> 同源策略与跨域
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Never.jpg"
                alt="Never" />
            
              <p class="site-author-name" itemprop="name">Never</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LJPNever" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1048435816@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Springboot-启动相关"><span class="nav-text">Springboot 启动相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-run关键："><span class="nav-text">Application run关键：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-IOC；"><span class="nav-text">Spring IOC；</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC"><span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aop"><span class="nav-text">aop</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Never</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytyqQfqe';
      var conf = '6a41e203093499026ca336cb276dfdc4';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
